#include <algorithm>
#include <math.h>
#include "idefix.hpp"
#include "setup.hpp"
#include "planet.hpp"

real wkzMinGlob;
real wkzMaxGlob;
real wkzDampingGlob;
real sigma0Glob;
real sigmaSlopeGlob;
real h0Glob;
real flaringIndexGlob;
real alphaGlob;
real densityFloorGlob;
real masstaperGlob;
real omegaGlob;

real nuGlob;
real betaGlob;
real chiGlob;

real kappa0Glob;
real kslopeGlob;

std::string outpathGlob;


void MyThermalDiffusivity(DataBlock &data, const real t, IdefixArray3D<real> &kappa) {
  IdefixArray1D<real> x1 = data.x[IDIR];
  real kappa0 = kappa0Glob;
  real kslope = kslopeGlob;

  idefix_for("MyThermalDiffusivity", 0, data.np_tot[KDIR],
                                      0, data.np_tot[JDIR],
                                      0, data.np_tot[IDIR],
      KOKKOS_LAMBDA (int k, int j, int i) {
        real R = x1(i);
        kappa(k,j,i) = kappa0 * pow(R, kslope);
  });
}


void MySoundSpeed(DataBlock &data, const real t, IdefixArray3D<real> &cs) {
  real h0 = h0Glob;
  real flaringIndex = flaringIndexGlob;
  IdefixArray1D<real> x1=data.x[IDIR];
  idefix_for("MySoundSpeed",0,data.np_tot[KDIR],0,data.np_tot[JDIR],0,data.np_tot[IDIR],
              KOKKOS_LAMBDA (int k, int j, int i) {
                real R = x1(i);
                cs(k,j,i) = h0*pow(R,flaringIndex-0.5);
              });
}


void MyViscosity(DataBlock &data, const real t, IdefixArray3D<real> &eta1, IdefixArray3D<real> &eta2) {
  IdefixArray4D<real> Vc=data.hydro->Vc;
  IdefixArray1D<real> x1=data.x[IDIR];
  real h0 = h0Glob;
  real flaringIndex = flaringIndexGlob;
  real alpha = alphaGlob;
  real nu = nuGlob;  // ✅ use global variable
  idefix_for("MyViscosity",0,data.np_tot[KDIR],0,data.np_tot[JDIR],0,data.np_tot[IDIR],
              KOKKOS_LAMBDA (int k, int j, int i) {
                real R = x1(i);
                real cs = h0*pow(R,flaringIndex-0.5);
                //eta1(k,j,i) = alpha*cs*h0*pow(R,flaringIndex+1)*Vc(RHO,k,j,i);
                eta1(k,j,i) = nu * Vc(RHO,k,j,i);
                eta2(k,j,i) = ZERO_F;
              });

}

void Damping(Hydro *hydro, const real t, const real dtin) {
  auto *data = hydro->data;
  real beta = betaGlob;  // ✅ use global variable
  real chi = chiGlob;
  IdefixArray4D<real> Vc = hydro->Vc;
  IdefixArray4D<real> Uc = hydro->Uc;
  IdefixArray1D<real> x1 = data->x[IDIR];
  IdefixArray1D<real> x2 = data->x[JDIR];

  real h0 = h0Glob;
  real sigma0 = sigma0Glob;
  real sigmaSlope = sigmaSlopeGlob;
  real flaringIndex = flaringIndexGlob;
  real omega = omegaGlob;
  real gamma = hydro->eos->GetGamma();
  real dt = dtin;
  bool isFargo = data->haveFargo;

  real rmin{data->mygrid->xbeg[0]};
  real wkzMin{wkzMinGlob};
  real rmax{data->mygrid->xend[0]};
  real wkzMax{wkzMaxGlob};
  real wkzDamping{wkzDampingGlob};
  idefix_for("MySourceTerm",
    0, data->np_tot[KDIR],
    0, data->np_tot[JDIR],
    0, data->np_tot[IDIR],
              KOKKOS_LAMBDA (int k, int j, int i) {
                real R = x1(i);
                real Vk = 1.0/sqrt(R);

               // /*
                #ifndef ISOTHERMAL
                #ifdef BETACOOLING
                // Beta Cooling function
                real cs2 = h0*h0*pow(R,2*flaringIndex-1.0);

                // cooling time in local Keplerian units
               // real tau = 0.1*pow(R,1.5);
                real tau = beta*pow(R,1.5);
                real Ptarget = cs2*Vc(RHO,k,j,i);

                //Uc(ENG,k,j,i) += -dt*(Vc(PRS,k,j,i)-Ptarget)/(tau*(gamma-1.0));

                real Eint = Uc(ENG,k,j,i);  // internal energy
                real Eeq = Ptarget / (gamma - 1.0);  // equilibrium energy
                real factor = 1.0 / (1.0 + dt / tau);
                Uc(ENG,k,j,i) = Eint * factor + Eeq * (1.0 - factor);
               // */
                #endif

                #ifdef THERMALDIFFUSION
                                // Thermal Diffusion

                                // Compute entropy
                                real S_c = log(Vc(PRS,k,j,i) / pow(Vc(RHO,k,j,i), gamma));

                                real lap_r = 0.0;
                                real lap_phi = 0.0;
                                real lap_z = 0.0;
                                real lap_S = 0.0;

                                // === Radial Laplacian (cylindrical) ===
                                if(i >= data->beg[IDIR] && i < data->end[IDIR]) {
                                    real dr = data->dx[IDIR](i);
                                    real S_p = log(Vc(PRS,k,j,i+1) / pow(Vc(RHO,k,j,i+1), gamma));
                                    real S_m = log(Vc(PRS,k,j,i-1) / pow(Vc(RHO,k,j,i-1), gamma));
                                    real dS_dr_plus  = (S_p - S_c) / dr;
                                    real dS_dr_minus = (S_c - S_m) / dr;
                                    lap_r = (1.0 / R) * ((R + 0.5 * dr) * dS_dr_plus - (R - 0.5 * dr) * dS_dr_minus) / dr;
                                }

                                // === Azimuthal Laplacian (with periodic wraparound) ===
                                if(j >= data->beg[JDIR] && j < data->end[JDIR]) {
                                    real dphi = data->dx[JDIR](j);

                                    int jp = j + 1;
                                    int jm = j - 1;
                                    if(jp >= data->end[JDIR]) jp = data->beg[JDIR];
                                    if(jm <  data->beg[JDIR]) jm = data->end[JDIR] - 1;

                                    real S_p = log(Vc(PRS,k,jp,i) / pow(Vc(RHO,k,jp,i), gamma));
                                    real S_m = log(Vc(PRS,k,jm,i) / pow(Vc(RHO,k,jm,i), gamma));
                                    lap_phi = (S_p - 2.0 * S_c + S_m) / (dphi * dphi) / (R * R);
                                }

                                // === Vertical Laplacian (Cartesian) ===
                                if(k >= data->beg[KDIR] && k < data->end[KDIR]) {
                                    real dz = data->dx[KDIR](k);
                                    real S_p = log(Vc(PRS,k+1,j,i) / pow(Vc(RHO,k+1,j,i), gamma));
                                    real S_m = log(Vc(PRS,k-1,j,i) / pow(Vc(RHO,k-1,j,i), gamma));
                                    lap_z = (S_p - 2.0 * S_c + S_m) / (dz * dz);
                                }

                                lap_S = lap_r + lap_phi + lap_z;

                                // Crank-Nicolson update
                                real update_factor = (1.0 + 0.5 * dt * chi * lap_S) / (1.0 - 0.5 * dt * chi * lap_S);
                                Uc(ENG,k,j,i) *= update_factor;
                #endif


               #endif
                real lambda = 0.0;

                // Damping function for poloidal velocity field in damping zones
                // Damp whatever is at R<wkzMin and R>wkzMax
                if (R<wkzMin) {
                  lambda = 1.0/(wkzDamping*2.0*M_PI*pow(rmin,1.5))*(1.0 - pow(sin(M_PI*( (R-rmin) / (wkzMin-rmin) )/2.0),2.0));
                }
                if (R>wkzMax) {
                  lambda = 1.0/(wkzDamping*2.0*M_PI*pow(rmax,1.5))*pow(sin(M_PI*( (R-wkzMax) / (rmax-wkzMax) )/2.0),2.0);
                }

                real rhoTarget = sigma0*pow(R,-sigmaSlope) ;
                real vx2Target = 0.0;
                if(!isFargo) {
                  vx2Target = Vk*sqrt(1.0-(1.0+sigmaSlope-2*flaringIndex)*h0*h0*pow(R,2*flaringIndex)) - omega * R;
                }

                // relaxation
                real drho = lambda*(Vc(RHO,k,j,i)-rhoTarget);
                real dvx1 = lambda*Vc(RHO,k,j,i)*Vc(VX1,k,j,i);
                real dvx2 = lambda*Vc(RHO,k,j,i)*(Vc(VX2,k,j,i)-vx2Target);
                real dvx3 = lambda*Vc(RHO,k,j,i)*Vc(VX3,k,j,i);

                real dmx1 = dvx1 + Vc(VX1,k,j,i) * drho;
                real dmx2 = dvx2 + Vc(VX2,k,j,i) * drho;
                real dmx3 = dvx3 + Vc(VX3,k,j,i) * drho;

                // Kinetic energy fluctuations due to above damping
                // must be compensated in total energy conservation
                /*
                real deng = 0.5*(Vc(VX1,k,j,i)*Vc(VX1,k,j,i)
                                +Vc(VX2,k,j,i)*Vc(VX2,k,j,i))*drho
                                +Vc(VX3,k,j,i)*Vc(VX3,k,j,i))*drho
                            + Vc(RHO,k,j,i) * (
                                  Vc(VX1,k,j,i)*dvx1
                                + Vc(VX2,k,j,i)*dvx2
                                + Vc(VX3,k,j,i)*dvx3
                            );
                */

                Uc(RHO,k,j,i) += -drho*dt;
                Uc(MX1,k,j,i) += -dmx1*dt;
                Uc(MX2,k,j,i) += -dmx2*dt;
                Uc(MX3,k,j,i) += -dmx3*dt;
                // Uc(ENG,k,j,i) += -deng*dt;

});

}

// User-defined boundaries
void UserdefBoundary(Hydro *hydro, int dir, BoundarySide side, real t) {
  auto *data = hydro->data;
  IdefixArray4D<real> Vc = hydro->Vc;
  IdefixArray1D<real> x1 = data->x[IDIR];
  real sigmaSlope=sigmaSlopeGlob;
  real omega = omegaGlob;
  real h0 = h0Glob;
  real flaringIndex = flaringIndexGlob;

    if(dir==IDIR) {
        int ighost,ibeg,iend,sign;
        if(side == left) {
            ighost = data->beg[IDIR];
            ibeg = 0;
            iend = data->beg[IDIR];
            sign=-1;
            //return;
        }
        else if(side==right) {
            ighost = data->end[IDIR]-1;
            ibeg=data->end[IDIR];
            iend=data->np_tot[IDIR];
            sign=1;
        }


        idefix_for("UserDefBoundary",
          0, data->np_tot[KDIR],
          0, data->np_tot[JDIR],
          ibeg, iend,
                    KOKKOS_LAMBDA (int k, int j, int i) {
                        real R=x1(i);
                        real R0=x1(ighost);
                        real Vk = 1.0/sqrt(R);

                        Vc(RHO,k,j,i) = Vc(RHO,k,j,ighost)*pow(R/R0,-sigmaSlope) ;

                        #ifndef ISOTHERMAL
                              real cs2 = h0 * h0 * pow(R, 2 * flaringIndex - 1.0);
                              Vc(PRS, k, j, i) = cs2 * Vc(RHO, k, j, i);
                        #endif

                        if( sign*Vc(VX1,k,j,ighost) > 0.0) {
                          Vc(VX1,k,j,i) = Vc(VX1,k,j,ighost);
                        } else {
                          Vc(VX1,k,j,i) = - Vc(VX1,k,j,2*ighost-i+sign);
                        }

                        Vc(VX2,k,j,i) = Vc(VX2,k,j,ighost)*pow(R/R0,-0.5) - omega*R ;
                        Vc(VX3,k,j,i) = Vc(VX3,k,j,ighost);

                        // Vc(RHO,k,j,i) = sigma0*pow(R,-sigmaSlope) ;
                        // Vc(VX2,k,j,i) = Vk*sqrt(1.0-(1.0+sigmaSlope-2*flaringIndex)*h0*h0*pow(R,2*flaringIndex)) - omega * R;
                        // Vc(VX3,k,j,i) = Vc(VX3,k,j,2*ighost-i+sign);
                    });
    }
}

void FargoVelocity(DataBlock &data, IdefixArray2D<real> &Vphi) {
  IdefixArray1D<real> x1 = data.x[IDIR];
  real sigmaSlope=sigmaSlopeGlob;
  real h0=h0Glob;
  real flaringIndex=flaringIndexGlob;
  real omega = omegaGlob;

  idefix_for("FargoVphi",0,data.np_tot[KDIR], 0, data.np_tot[IDIR],
      KOKKOS_LAMBDA (int k, int i) {
        real R = x1(i);
        real Vk = 1.0/sqrt(R);
        // Vphi(k,i) = 1.0/sqrt(R) - omega*R;
        Vphi(k,i) = Vk*sqrt(1.0-(1.0+sigmaSlope-2*flaringIndex)*h0*h0*pow(R,2*flaringIndex)) - omega * R;
  });
}

// Analyse data to produce an ascii output
void Analysis(DataBlock & data) {
  // Mirror data on Host
  DataBlockHost d(data);

  // Sync it
  d.SyncFromDevice();

//  data.DumpToFile("totou");

  for(int ip=0; ip < data.planetarySystem->nbp ; ip++) {
    // Get the orbital parameters
    real timeStep = data.dt;
    real xp = data.planetarySystem->planet[ip].getXp();
    real yp = data.planetarySystem->planet[ip].getYp();
    real zp = data.planetarySystem->planet[ip].getZp();
    real vxp = data.planetarySystem->planet[ip].getVxp();
    real vyp = data.planetarySystem->planet[ip].getVyp();
    real vzp = data.planetarySystem->planet[ip].getVzp();
    real qp = data.planetarySystem->planet[ip].getMp();
    real time = data.t;

    std::string planetName, tqwkName;
    std::stringstream pName, tName;
    pName << outpathGlob << "/planet" << ip << ".dat";
    tName << outpathGlob << "/tqwk" << ip << ".dat";
    planetName = pName.str();
    tqwkName = tName.str();
    // Write the data in ascii to our file
    if(idfx::prank==0) {
      std::ofstream f;
      f.open(planetName,std::ios::app);
      f.precision(10);
      f << std::scientific << timeStep << "    " << xp << "    " << yp << "    " << zp << "    " << vxp << "    " << vyp << "    " << vzp << "    " << qp << "    " << time << std::endl;
      f.close();
    }

    // Force force = {{0.0,0.0,0.0},{0.0,0.0,0.0},{0.0,0.0,0.0},{0.0,0.0,0.0}};
    Force &force = data.planetarySystem->planet[ip].m_force;
    bool isp = true;
    data.planetarySystem->planet[ip].computeForce(data,isp);

    // Get the torque and work
    // real fxi = force.f_inner[0];
    // real fyi = force.f_inner[1];
    // real fzi = force.f_inner[2];
    // real fxo = force.f_outer[0];
    // real fyo = force.f_outer[1];
    // real fzo = force.f_outer[2];
    // real fxhi = force.f_ex_inner[0];
    // real fyhi = force.f_ex_inner[1];
    // real fzhi = force.f_ex_inner[2];
    // real fxho = force.f_ex_outer[0];
    // real fyho = force.f_ex_outer[1];
    // real fzho = force.f_ex_outer[2];

    real tq_inner = xp*force.f_inner[1]-yp*force.f_inner[0];
    real tq_outer = xp*force.f_outer[1]-yp*force.f_outer[0];
    real tq_ex_inner = xp*force.f_ex_inner[1]-yp*force.f_ex_inner[0];
    real tq_ex_outer = xp*force.f_ex_outer[1]-yp*force.f_ex_outer[0];
    real wk_inner = vxp*force.f_inner[0]+vyp*force.f_inner[1];
    real wk_outer = vxp*force.f_outer[0]+vyp*force.f_outer[1];
    real wk_ex_inner = vxp*force.f_ex_inner[0]+vyp*force.f_ex_inner[1];
    real wk_ex_outer = vxp*force.f_ex_outer[0]+vyp*force.f_ex_outer[1];

    // Write the data in ascii to our file
    if(idfx::prank==0) {
      std::ofstream ft;
      ft.open(tqwkName,std::ios::app);
      ft.precision(10);
      // ft << std::scientific << timeStep << "    " << fxi << "    " << fyi << "    " << fzi << "    " << fxo << "    " << fyo << "    " << fzo << "    " << fxhi << "    " << fyhi << "    " << fzhi << "    " << fxho << "    " << fyho << "    " << fzho << "    " << time << std::endl;
      ft << std::scientific << timeStep << "    " << tq_inner << "    " << tq_outer << "    " << tq_ex_inner << "    " << tq_ex_outer << "    " << wk_inner << "    " << wk_outer << "    " << wk_ex_inner << "    " << wk_ex_outer << "    " << time << std::endl;
      ft.close();
    }
  }
}

/*
// Compute user variables which will be written in vtk files
void ComputeUserVars(DataBlock & data, UserDefVariablesContainer &variables) {
  // Mirror data on Host
  real h0=h0Glob;
  real flaringIndex=flaringIndexGlob;
  DataBlockHost d(data);

  // Sync it
  d.SyncFromDevice();

  // Make references to the user-defined arrays (variables is a container of IdefixHostArray3D)
  // Note that the labels should match the variable names in the input file
  IdefixHostArray3D<real> PRS = variables["PRS"];

  for(int k = 0; k < d.np_tot[KDIR] ; k++) {
    for(int j = 0; j < d.np_tot[JDIR] ; j++) {
      for(int i = 0; i < d.np_tot[IDIR] ; i++) {
        real R = d.x[IDIR](i);
        real cs2 = h0*h0*pow(R,2*flaringIndex-1.);
        PRS(k,j,i) = cs2*d.Vc(RHO,k,j,i);
      }
    }
  }
}
*/

// Default constructor
// Initialisation routine. Can be used to allocate
// Arrays or variables which are used later on
Setup::Setup(Input &input, Grid &grid, DataBlock &data, Output &output) {
  // Set the function for userdefboundary
  data.hydro->EnrollUserDefBoundary(&UserdefBoundary);
  data.hydro->EnrollUserSourceTerm(&Damping);
#ifdef ISOTHERMAL
  data.hydro->EnrollIsoSoundSpeed(&MySoundSpeed);
#endif
#ifndef ISOTHERMAL
//data.hydro->EnrollUserDefThermalDiffusivity(MyThermalDiffusivity);
#endif

  if(data.haveFargo) {
    std::cout << "✅ data.haveFargo = true — enrolling FargoVelocity" << std::endl;
    data.fargo->EnrollVelocity(&FargoVelocity);
  } else {
    std::cout << "❌ data.haveFargo = false — not enrolling FargoVelocity" << std::endl;
  }

  if(data.hydro->haveRotation) {
    omegaGlob = data.hydro->OmegaZ;
  } else {
    omegaGlob = 0.0;
  }

  // Enroll the analysis function
  output.EnrollAnalysis(&Analysis);
  // output.EnrollUserDefVariables(&ComputeUserVars);

  // Global parameters
  wkzMinGlob = input.Get<real>("Setup","wkzMin",0);
  wkzMaxGlob = input.Get<real>("Setup","wkzMax",0);
  wkzDampingGlob = input.Get<real>("Setup","wkzDamping",0);
  sigma0Glob = input.Get<real>("Setup","sigma0",0);
  sigmaSlopeGlob = input.Get<real>("Setup","sigmaSlope",0);
  h0Glob = input.Get<real>("Setup","h0",0);
  flaringIndexGlob = input.Get<real>("Setup","flaringIndex",0);
  densityFloorGlob = input.Get<real>("Setup","densityFloor",0);
  masstaperGlob = input.Get<real>("Planet","masstaper",0);
  nuGlob = input.Get<real>("Setup", "nu", 0);
  betaGlob = input.Get<real>("eos", "beta", 0);
  chiGlob = input.Get<real>("Setup", "chi", 0);
  kappa0Glob = input.Get<real>("eos", "kappa0", 0);
  kslopeGlob = input.Get<real>("eos", "kslope", 0);

  // Output path
  outpathGlob = input.Get<std::string>("Output", "path", 0);

  // Create planet & torque/work output files in correct path
  for(int ip = 0; ip < data.planetarySystem->nbp; ip++) {
    std::stringstream pName, tName;
    pName << outpathGlob << "/planet" << ip << ".dat";
    tName << outpathGlob << "/tqwk" << ip << ".dat";
    std::string planetName = pName.str();
    std::string tqwkName = tName.str();

    if (!(input.restartRequested)) {
        if(idfx::prank == 0) {
            std::ofstream f(planetName, std::ios::out);
            f.close();
            std::ofstream ft(tqwkName, std::ios::out);
            ft.close();
        }
    }
  }
}

// This routine initialize the flow
// Note that data is on the device.
// One can therefore define locally
// a datahost and sync it, if needed
void Setup::InitFlow(DataBlock &data) {
    // Create a host copy
    DataBlockHost d(data);
    real h0=h0Glob;
    real sigma0=sigma0Glob;
    real sigmaSlope=sigmaSlopeGlob;
    real flaringIndex=flaringIndexGlob;
    real omega=omegaGlob;

    for(int k = 0; k < d.np_tot[KDIR] ; k++) {
        for(int j = 0; j < d.np_tot[JDIR] ; j++) {
            for(int i = 0; i < d.np_tot[IDIR] ; i++) {
                real R = d.x[IDIR](i);
                real z = d.x[KDIR](k);
                real Vk = 1.0/sqrt(R);

                d.Vc(RHO,k,j,i) = sigma0*pow(R,-sigmaSlope) ;

                #ifndef ISOTHERMAL
                                real cs2 = h0 * h0 * pow(R, 2 * flaringIndex - 1.0);
                                d.Vc(PRS, k, j, i) = cs2 * d.Vc(RHO, k, j, i);
                #endif

                d.Vc(VX1,k,j,i) = 0.0;
                d.Vc(VX2,k,j,i) = Vk*sqrt(1.0-(1.0+sigmaSlope-2*flaringIndex)*h0*h0*pow(R,2*flaringIndex)) - omega * R;
                d.Vc(VX3,k,j,i) = 0.0;

                if(d.Vc(RHO,k,j,i) < densityFloorGlob) {
                  d.Vc(RHO,k,j,i) = densityFloorGlob;
                }
            }
        }
    }

    // Send it all, if needed
    d.SyncToDevice();
}

// Analyse data to produce an output
void MakeAnalysis(DataBlock & data) {

}

// Destructor (required to avoid linker error)
Setup::~Setup() {
  // Nothing to clean up
}
