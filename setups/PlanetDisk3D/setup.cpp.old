#include <algorithm>
#include <math.h>
#include "idefix.hpp"
#include "setup.hpp"
#include "planet.hpp"


real wkzMinGlob;
real wkzMaxGlob;
real wkzDampingGlob;
real sigma0Glob;
real sigmaSlopeGlob;
real h0Glob;
real flaringIndexGlob;
real alphaGlob;
real densityFloorGlob;
real masstaperGlob;
real omegaGlob;

real nuGlob;
real betaGlob;
real gammaGlob;
real chiGlob;

real kappa0Glob;
real kslopeGlob;

std::string outpathGlob;


void MyThermalDiffusivity(DataBlock &data, const real t, IdefixArray3D<real> &kappa) {
  const real kappa0 = kappa0Glob;
  const real kslope = kslopeGlob;
  IdefixArray1D<real> x1 = data.x[IDIR];


  idefix_for("MyThermalDiffusivity",
             0, data.np_tot[KDIR],
             0, data.np_tot[JDIR],
             0, data.np_tot[IDIR],
    KOKKOS_LAMBDA(int k, int j, int i) {
      real R = x1(i);
      kappa(k,j,i) = kappa0 * pow(R, kslope);
  });
}

void MySoundSpeed(DataBlock &data, const real t, IdefixArray3D<real> &cs) {
  real h0 = h0Glob;
  real flaringIndex = flaringIndexGlob;
  IdefixArray1D<real> x1=data.x[IDIR];
  idefix_for("MySoundSpeed",0,data.np_tot[KDIR],0,data.np_tot[JDIR],0,data.np_tot[IDIR],
              KOKKOS_LAMBDA (int k, int j, int i) {
                real R = x1(i);
                cs(k,j,i) = h0*pow(R,flaringIndex-0.5);
              });
}


void MyViscosity(DataBlock &data, const real t,
                 IdefixArray3D<real> &eta1,
                 IdefixArray3D<real> &eta2) {
  IdefixArray4D<real> Vc = data.hydro->Vc;
  IdefixArray1D<real> x1 = data.x[IDIR];

  //real alpha = alphaGlob;
  //real h0 = h0Glob;
  //real flaringIndex = flaringIndexGlob;
  real nuslope = sigmaSlopeGlob-0.5;
  real nu0 = nuGlob;              // ðŸ‘ˆ your base nu (as in FARGO)

  idefix_for("MyViscosity",
             0, data.np_tot[KDIR],
             0, data.np_tot[JDIR],
             0, data.np_tot[IDIR],
    KOKKOS_LAMBDA(int k, int j, int i) {
      real R = x1(i);
      real nu = nu0 * pow(R, nuslope);        // ðŸ‘ˆ same as in FARGO
      eta1(k,j,i) = nu * Vc(RHO,k,j,i);
      eta2(k,j,i) = ZERO_F;
  });
}

void Damping(Hydro *hydro, const real t, const real dtin) {
  auto *data = hydro->data;
  real beta = betaGlob;  // âœ… use global variable
  real chi = chiGlob;
  IdefixArray4D<real> Vc = hydro->Vc;
  IdefixArray4D<real> Uc = hydro->Uc;
  IdefixArray1D<real> x1 = data->x[IDIR];
  IdefixArray1D<real> x2 = data->x[JDIR];

  real h0 = h0Glob;
  real sigma0 = sigma0Glob;
  real sigmaSlope = sigmaSlopeGlob;
  real flaringIndex = flaringIndexGlob;
  real omega = omegaGlob;
  real gamma = gammaGlob;
  real dt = dtin;
  bool isFargo = data->haveFargo;

  real rmin{data->mygrid->xbeg[0]};
  real wkzMin{wkzMinGlob};
  real rmax{data->mygrid->xend[0]};
  real wkzMax{wkzMaxGlob};
  real wkzDamping{wkzDampingGlob};
  idefix_for("MySourceTerm",
    0, data->np_tot[KDIR],
    0, data->np_tot[JDIR],
    0, data->np_tot[IDIR],
              KOKKOS_LAMBDA (int k, int j, int i) {
                real R = x1(i);
                real Vk = 1.0/sqrt(R);

               
// === Original IDEFIX damping zone ===


                real lambda = 0.0;

                // Damping function for poloidal velocity field in damping zones
                // Damp whatever is at R<wkzMin and R>wkzMax
                if (R<wkzMin) {
                  lambda = 1.0/(wkzDamping*2.0*M_PI*pow(rmin,1.5))*(1.0 - pow(sin(M_PI*( (R-rmin) / (wkzMin-rmin) )/2.0),2.0));
                }
                if (R>wkzMax) {
                  lambda = 1.0/(wkzDamping*2.0*M_PI*pow(rmax,1.5))*pow(sin(M_PI*( (R-wkzMax) / (rmax-wkzMax) )/2.0),2.0);
                }

                real rhoTarget = sigma0*pow(R,-sigmaSlope) ;
                real vx2Target = 0.0;
                if(!isFargo) {
                  vx2Target = Vk*sqrt(1.0-(1.0+sigmaSlope-2*flaringIndex)*h0*h0*pow(R,2*flaringIndex)) - omega * R;
                }

                // relaxation
                real drho = lambda * (Vc(RHO,k,j,i) - rhoTarget);
                real dvx1 = lambda * Vc(RHO,k,j,i) * Vc(VX1,k,j,i);
                real dvx2 = lambda * Vc(RHO,k,j,i) * (Vc(VX2,k,j,i) - vx2Target);
                real dvx3 = lambda * Vc(RHO,k,j,i) * Vc(VX3,k,j,i);

                real dmx1 = dvx1 + Vc(VX1,k,j,i) * drho;
                real dmx2 = dvx2 + Vc(VX2,k,j,i) * drho;
                real dmx3 = dvx3 + Vc(VX3,k,j,i) * drho;

                real deng = 0.5 * (
                      Vc(VX1,k,j,i) * Vc(VX1,k,j,i)
                    + Vc(VX2,k,j,i) * Vc(VX2,k,j,i)
                    + Vc(VX3,k,j,i) * Vc(VX3,k,j,i)
                  ) * drho
                + Vc(RHO,k,j,i) * (
                      Vc(VX1,k,j,i) * dvx1
                    + Vc(VX2,k,j,i) * dvx2
                    + Vc(VX3,k,j,i) * dvx3
                  );

                #ifndef ISOTHERMAL
                  real P       = Vc(PRS,k,j,i);
                  real cs2     = h0 * h0 * pow(R, 2 * flaringIndex - 1.0);
                  real Ptarget = cs2 * rhoTarget;
                  deng += lambda * (P - Ptarget) / (gamma - 1.0);
                #endif

                #ifdef STOCKHOLM
                Uc(RHO,k,j,i) += -drho * dt;
                Uc(MX1,k,j,i) += -dmx1 * dt;
                Uc(MX2,k,j,i) += -dmx2 * dt;
                Uc(MX3,k,j,i) += -dmx3 * dt;
                Uc(ENG,k,j,i) += -deng * dt;
                #endif




});

}

// User-defined boundaries
void UserdefBoundary(Hydro *hydro, int dir, BoundarySide side, real t) {
  auto *data = hydro->data;
  IdefixArray4D<real> Vc = hydro->Vc;
  IdefixArray1D<real> x1 = data->x[IDIR];
  real sigmaSlope=sigmaSlopeGlob;
  real omega = omegaGlob;
  real h0 = h0Glob;
  real sigma0 = sigma0Glob;  // Make sure this is defined appropriately
  real flaringIndex = flaringIndexGlob;
  real gamma = gammaGlob;

    if(dir==IDIR) {
        int ighost,ibeg,iend,sign;
        if(side == left) {
            ighost = data->beg[IDIR];
            ibeg = 0;
            iend = data->beg[IDIR];
            sign=-1;
            //return;
        }
        else if(side==right) {
            ighost = data->end[IDIR]-1;
            ibeg=data->end[IDIR];
            iend=data->np_tot[IDIR];
            sign=1;
        }


        idefix_for("UserDefBoundary",
          0, data->np_tot[KDIR],
          0, data->np_tot[JDIR],
          ibeg, iend,
                    KOKKOS_LAMBDA (int k, int j, int i) {
                        real R=x1(i);
                        real R0=x1(ighost);
                        real Vk = 1.0/sqrt(R);
                        //------------------------ OLD ------------------------------
                        //Vc(RHO,k,j,i) = Vc(RHO,k,j,ighost)*pow(R/R0,-sigmaSlope) ;

                        //if( sign*Vc(VX1,k,j,ighost) > 0.0) {
                        //  Vc(VX1,k,j,i) = Vc(VX1,k,j,ighost);
                       // } else {
                        //  Vc(VX1,k,j,i) = - Vc(VX1,k,j,2*ighost-i+sign);
                        //}

                        //Vc(VX2,k,j,i) = Vc(VX2,k,j,ighost)*pow(R/R0,-0.5) - omega*R ;
                        //Vc(VX3,k,j,i) = Vc(VX3,k,j,ighost);



                        // Vc(RHO,k,j,i) = sigma0*pow(R,-sigmaSlope) ;
                        // Vc(VX2,k,j,i) = Vk*sqrt(1.0-(1.0+sigmaSlope-2*flaringIndex)*h0*h0*pow(R,2*flaringIndex)) - omega * R;
                        // Vc(VX3,k,j,i) = Vc(VX3,k,j,2*ighost-i+sign);

                        //------------------------ NEW ------------------------------

                        Vc(RHO,k,j,i) = sigma0 * pow(R, -sigmaSlope);

                        // Keplerian + pressure gradient
                        real pressure_correction = 1.0 - (1.0 + sigmaSlope - 2.0 * flaringIndex) * h0 * h0 * pow(R, 2.0 * flaringIndex);
                        Vc(VX2,k,j,i) = Vk * sqrt(pressure_correction) - omega * R;

                        // Strict zero radial flow
                        Vc(VX1,k,j,i) = 0.0;

                        // Leave vertical velocity untouched in 2D (or set to 0 for symmetry):
                        Vc(VX3,k,j,i) = 0.0;

                        #ifndef ISOTHERMAL
                              real cs2 = h0 * h0 * pow(R, 2 * flaringIndex - 1.0);
                              Vc(PRS, k, j, i) = cs2 * Vc(RHO, k, j, i);
                        #endif


                        //#ifndef ISOTHERMAL
                        //    real cs2 = h0 * h0 * pow(R, 2 * flaringIndex - 1.0);
                        //    real rho = Vc(RHO, k, j, i);
                        //    real vx1 = Vc(VX1, k, j, i);
                        //    real vx2 = Vc(VX2, k, j, i);
                        //    real vx3 = Vc(VX3, k, j, i);
                        //    real eng = cs2 * rho / (gamma - 1.0);
                        //               + 0.5 * rho * (vx1*vx1 + vx2*vx2 + vx3*vx3);
                       //     Vc(ENG, k, j, i) = eng;
                       // #endif

                    });
    }
}

void FargoVelocity(DataBlock &data, IdefixArray2D<real> &Vphi) {
  IdefixArray1D<real> x1 = data.x[IDIR];
  real sigmaSlope=sigmaSlopeGlob;
  real h0=h0Glob;
  real flaringIndex=flaringIndexGlob;
  real omega = omegaGlob;

  idefix_for("FargoVphi",0,data.np_tot[KDIR], 0, data.np_tot[IDIR],
      KOKKOS_LAMBDA (int k, int i) {
        real R = x1(i);
        real Vk = 1.0/sqrt(R);
        // Vphi(k,i) = 1.0/sqrt(R) - omega*R;
        Vphi(k,i) = Vk*sqrt(1.0-(1.0+sigmaSlope-2*flaringIndex)*h0*h0*pow(R,2*flaringIndex)) - omega * R;
  });
}

// Analyse data to produce an ascii output
void Analysis(DataBlock & data) {
  // Mirror data on Host
  DataBlockHost d(data);

  // Sync it
  d.SyncFromDevice();

//  data.DumpToFile("totou");

  for(int ip=0; ip < data.planetarySystem->nbp ; ip++) {
    // Get the orbital parameters
    real timeStep = data.dt;
    real xp = data.planetarySystem->planet[ip].getXp();
    real yp = data.planetarySystem->planet[ip].getYp();
    real zp = data.planetarySystem->planet[ip].getZp();
    real vxp = data.planetarySystem->planet[ip].getVxp();
    real vyp = data.planetarySystem->planet[ip].getVyp();
    real vzp = data.planetarySystem->planet[ip].getVzp();
    real qp = data.planetarySystem->planet[ip].getMp();
    real time = data.t;

    std::string planetName, tqwkName;
    std::stringstream pName, tName;
    pName << outpathGlob << "/planet" << ip << ".dat";
    tName << outpathGlob << "/tqwk" << ip << ".dat";
    planetName = pName.str();
    tqwkName = tName.str();
    // Write the data in ascii to our file
    if(idfx::prank==0) {
      std::ofstream f;
      f.open(planetName,std::ios::app);
      f.precision(10);
      f << std::scientific << timeStep << "    " << xp << "    " << yp << "    " << zp << "    " << vxp << "    " << vyp << "    " << vzp << "    " << qp << "    " << time << std::endl;
      f.close();
    }

    // Force force = {{0.0,0.0,0.0},{0.0,0.0,0.0},{0.0,0.0,0.0},{0.0,0.0,0.0}};
    Force &force = data.planetarySystem->planet[ip].m_force;
    bool isp = true;
    data.planetarySystem->planet[ip].computeForce(data,isp);

    // Get the torque and work
    // real fxi = force.f_inner[0];
    // real fyi = force.f_inner[1];
    // real fzi = force.f_inner[2];
    // real fxo = force.f_outer[0];
    // real fyo = force.f_outer[1];
    // real fzo = force.f_outer[2];
    // real fxhi = force.f_ex_inner[0];
    // real fyhi = force.f_ex_inner[1];
    // real fzhi = force.f_ex_inner[2];
    // real fxho = force.f_ex_outer[0];
    // real fyho = force.f_ex_outer[1];
    // real fzho = force.f_ex_outer[2];

    real tq_inner = xp*force.f_inner[1]-yp*force.f_inner[0];
    real tq_outer = xp*force.f_outer[1]-yp*force.f_outer[0];
    real tq_ex_inner = xp*force.f_ex_inner[1]-yp*force.f_ex_inner[0];
    real tq_ex_outer = xp*force.f_ex_outer[1]-yp*force.f_ex_outer[0];
    real wk_inner = vxp*force.f_inner[0]+vyp*force.f_inner[1];
    real wk_outer = vxp*force.f_outer[0]+vyp*force.f_outer[1];
    real wk_ex_inner = vxp*force.f_ex_inner[0]+vyp*force.f_ex_inner[1];
    real wk_ex_outer = vxp*force.f_ex_outer[0]+vyp*force.f_ex_outer[1];

    // Write the data in ascii to our file
    if(idfx::prank==0) {
      std::ofstream ft;
      ft.open(tqwkName,std::ios::app);
      ft.precision(10);
      // ft << std::scientific << timeStep << "    " << fxi << "    " << fyi << "    " << fzi << "    " << fxo << "    " << fyo << "    " << fzo << "    " << fxhi << "    " << fyhi << "    " << fzhi << "    " << fxho << "    " << fyho << "    " << fzho << "    " << time << std::endl;
      ft << std::scientific << timeStep << "    " << tq_inner << "    " << tq_outer << "    " << tq_ex_inner << "    " << tq_ex_outer << "    " << wk_inner << "    " << wk_outer << "    " << wk_ex_inner << "    " << wk_ex_outer << "    " << time << std::endl;
      ft.close();
    }
  }
}

/*
// Compute user variables which will be written in vtk files
void ComputeUserVars(DataBlock & data, UserDefVariablesContainer &variables) {
  // Mirror data on Host
  real h0=h0Glob;
  real flaringIndex=flaringIndexGlob;
  DataBlockHost d(data);

  // Sync it
  d.SyncFromDevice();

  // Make references to the user-defined arrays (variables is a container of IdefixHostArray3D)
  // Note that the labels should match the variable names in the input file
  IdefixHostArray3D<real> PRS = variables["PRS"];

  for(int k = 0; k < d.np_tot[KDIR] ; k++) {
    for(int j = 0; j < d.np_tot[JDIR] ; j++) {
      for(int i = 0; i < d.np_tot[IDIR] ; i++) {
        real R = d.x[IDIR](i);
        real cs2 = h0*h0*pow(R,2*flaringIndex-1.);
        PRS(k,j,i) = cs2*d.Vc(RHO,k,j,i);
      }
    }
  }
}
*/

// Default constructor
// Initialisation routine. Can be used to allocate
// Arrays or variables which are used later on
Setup::Setup(Input &input, Grid &grid, DataBlock &data, Output &output) {
  // Set the function for userdefboundary            
  data.hydro->EnrollUserDefBoundary(&UserdefBoundary);
  data.hydro->EnrollUserSourceTerm(&Damping);


  data.hydro->viscosity->EnrollViscousDiffusivity(&MyViscosity);


#ifdef ISOTHERMAL
  data.hydro->EnrollIsoSoundSpeed(&MySoundSpeed);
#endif

#ifndef ISOTHERMAL
  #ifdef THERMALDIFFUSION
    data.hydro->EnrollUserDefThermalDiffusivity(MyThermalDiffusivity);
  #endif
#endif

  if(data.haveFargo) {
    std::cout << "âœ… data.haveFargo = true â€” enrolling FargoVelocity" << std::endl;
    data.fargo->EnrollVelocity(&FargoVelocity);
  } else {
    std::cout << "âŒ data.haveFargo = false â€” not enrolling FargoVelocity" << std::endl;
  }

  if(data.hydro->haveRotation) {
    omegaGlob = data.hydro->OmegaZ;
  } else {
    omegaGlob = 0.0;
  }

  // Enroll the analysis function
  output.EnrollAnalysis(&Analysis);
  // output.EnrollUserDefVariables(&ComputeUserVars);

  // Global parameters
  wkzMinGlob = input.Get<real>("Setup","wkzMin",0);
  wkzMaxGlob = input.Get<real>("Setup","wkzMax",0);
  wkzDampingGlob = input.Get<real>("Setup","wkzDamping",0);
  sigma0Glob = input.Get<real>("Setup","sigma0",0);
  sigmaSlopeGlob = input.Get<real>("Setup","sigmaSlope",0);
  h0Glob = input.Get<real>("Setup","h0",0);
  flaringIndexGlob = input.Get<real>("Setup","flaringIndex",0);
  densityFloorGlob = input.Get<real>("Setup","densityFloor",0);
  masstaperGlob = input.Get<real>("Planet","masstaper",0);
  nuGlob = input.Get<real>("Setup", "nu", 0);
  betaGlob = input.Get<real>("Hydro", "beta", 0);
  gammaGlob = input.Get<real>("Hydro", "gamma", 0);
  chiGlob = input.Get<real>("Hydro", "chi", 0);
  kappa0Glob = input.Get<real>("Hydro", "kappa0", 0);
  kslopeGlob = input.Get<real>("Hydro", "kslope", 0);

  // Output path
  outpathGlob = input.Get<std::string>("Output", "path", 0);

  // Create planet & torque/work output files in correct path
  for(int ip = 0; ip < data.planetarySystem->nbp; ip++) {
    std::stringstream pName, tName;
    pName << outpathGlob << "/planet" << ip << ".dat";
    tName << outpathGlob << "/tqwk" << ip << ".dat";
    std::string planetName = pName.str();
    std::string tqwkName = tName.str();

    if (!(input.restartRequested)) {
        if(idfx::prank == 0) {
            std::ofstream f(planetName, std::ios::out);
            f.close();
            std::ofstream ft(tqwkName, std::ios::out);
            ft.close();
        }
    }
  }
}

// This routine initialize the flow
// Note that data is on the device.
// One can therefore define locally
// a datahost and sync it, if needed
void Setup::InitFlow(DataBlock &data) {
    // Create a host copy
    DataBlockHost d(data);
    real h0=h0Glob;
    real sigma0=sigma0Glob;
    real sigmaSlope=sigmaSlopeGlob;
    real flaringIndex=flaringIndexGlob;
    real omega=omegaGlob;
    real gamma = gammaGlob;

    for(int k = 0; k < d.np_tot[KDIR] ; k++) {
        for(int j = 0; j < d.np_tot[JDIR] ; j++) {
            for(int i = 0; i < d.np_tot[IDIR] ; i++) {
                real R = d.x[IDIR](i);
                real z = d.x[KDIR](k);
                real Vk = 1.0/sqrt(R);

                d.Vc(RHO,k,j,i) = sigma0*pow(R,-sigmaSlope) ;

                #ifndef ISOTHERMAL
                                real cs2 = h0 * h0 * pow(R, 2 * flaringIndex - 1.0);
                                d.Vc(PRS, k, j, i) = cs2 * d.Vc(RHO, k, j, i);
                #endif

                d.Vc(VX1,k,j,i) = 0.0;
                d.Vc(VX2,k,j,i) = Vk*sqrt(1.0-(1.0+sigmaSlope-2*flaringIndex)*h0*h0*pow(R,2*flaringIndex)) - omega * R;
                d.Vc(VX3,k,j,i) = 0.0;


               // #ifndef ISOTHERMAL
               //     real cs2 = h0 * h0 * pow(R, 2 * flaringIndex - 1.0);
               //     real rho = d.Vc(RHO, k, j, i);
               //     real vx1 = d.Vc(VX1, k, j, i);
               //     real vx2 = d.Vc(VX2, k, j, i);
               //     real vx3 = d.Vc(VX3, k, j, i);
               //     real eng = cs2 * rho / (gamma - 1.0);
               //                + 0.5 * rho * (vx1*vx1 + vx2*vx2 + vx3*vx3);
               //     d.Vc(ENG, k, j, i) = eng;
               // #endif


//DEBUG//
if (i == 38 && j == 2 && k == 0) {
    printf("=== InitFlow PROBE ===\n");
    printf("  R = %.6f, z = %.6f\n", R, z);
    printf("  omega = %.6f\n", omega);
    printf("  Vphi_init = %.12e\n", d.Vc(VX2,k,j,i));
    real vk = 1.0 / sqrt(R);
    real vphi_lab = d.Vc(VX2,k,j,i) + omega * R;
    printf("  Vphi_lab (after +omega*r) = %.12e\n", vphi_lab);
    printf("  Expected v_K = %.12e\n", vk);
    printf("  Expected v_phi pressure support = %.12e\n", 
           vk * sqrt(1.0 - h0 * h0 * (1.0 + sigmaSlope - 2 * flaringIndex) * pow(R, 2 * flaringIndex)));
}





                if(d.Vc(RHO,k,j,i) < densityFloorGlob) {
                  d.Vc(RHO,k,j,i) = densityFloorGlob;
                }
            }
        }
    }

    // Send it all, if needed
    d.SyncToDevice();
}

// Analyse data to produce an output
void MakeAnalysis(DataBlock & data) {

}

// Destructor (required to avoid linker error)
Setup::~Setup() {
  // Nothing to clean up
}
